@page "/multifile"
@using Microsoft.Extensions.Logging
@using PoC1_LegacyAnalyzer_Web.Services
@using PoC1_LegacyAnalyzer_Web.Models
@using PoC1_LegacyAnalyzer_Web.Components.MultiFileAnalysis
@using PoC1_LegacyAnalyzer_Web.Components.Shared
@using PoC1_LegacyAnalyzer_Web.Helpers
@using Microsoft.AspNetCore.Components.Forms
@using System.Text
@using PoC1_LegacyAnalyzer_Web.Services.Infrastructure
@using PoC1_LegacyAnalyzer_Web.Services.Reporting
@inject IMultiFileAnalysisService MultiFileAnalysisService
@inject IFileDownloadService FileDownloadService
@inject IJSRuntime JSRuntime
@inject IReportService ReportService
@inject IConfiguration Configuration
@implements IAsyncDisposable

<PageTitle>Enterprise Project Analysis</PageTitle>

<div class="container-fluid">
    <div class="row mb-4">
        <div class="col-12 text-center">
            <h1 class="display-4 mb-2">Enterprise Project Analysis</h1>
            <p class="lead text-muted">Advanced Legacy System Assessment Platform</p>
        </div>
    </div>

    <!-- File Upload Card Component -->
    <div class="row section-main">
        <div class="col-12">
            <FileUploadCard
                SelectedFiles="selectedFiles"
                AnalysisType="@selectedAnalysisType"
                IsAnalyzing="@isAnalyzing"
                OnFileSelection="HandleFileSelection"
                OnIndividualFileSelection="HandleIndividualFileSelection"
                OnAnalyze="AnalyzeProject"
                OnClearFiles="ClearFiles"
                OnAnalysisTypeChange="HandleAnalysisTypeChange" />
        </div>
    </div>

    <!-- Progress Modal -->
    <AnalysisProgressModal IsVisible="@isAnalyzing" Progress="@analysisProgress" />

    <!-- Results Section - Single Column Layout -->
    @if (analysisResult != null)
    {
        <div class="row">
            <div class="col-12">
                <!-- Project Summary -->
                <ProjectSummaryCard Result="@analysisResult" />

                @*<div class="alert alert-info">
                    <h5>Executive Dashboard Ready</h5>
                    <p>Interactive charts loading... If charts don't appear, detailed metrics are available below.</p>
                    <button class="btn btn-outline-primary btn-sm" @onclick="TestSimpleCharts">
                        Validate Dashboard
                    </button>
                </div>*@

                <!-- Charts Section -->
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="alert alert-info">
                            <h5 class="alert-heading mb-3"><i class="bi bi-graph-up"></i> Executive Dashboard</h5>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card border-primary">
                                        <div class="card-header bg-primary text-white">
                                            <h6 class="mb-0">Files Requiring Immediate Review</h6>
                                            <small>Priority ranking by technical complexity</small>
                                        </div>
                                        <div class="card-body" style="height: 300px;">
                                            <canvas id="complexityChart" width="400" height="250"></canvas>
                                        </div>
                                        <div class="card-footer text-muted">
                                            <small><strong>Action:</strong> Focus development effort on highest-scoring files first</small>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card border-warning">
                                        <div class="card-header bg-warning text-dark">
                                            <h6 class="mb-0">Project Risk Assessment</h6>
                                            <small>Risk distribution across entire codebase</small>
                                        </div>
                                        <div class="card-body" style="height: 300px;">
                                            <canvas id="riskChart" width="400" height="250"></canvas>
                                        </div>
                                        <div class="card-footer text-muted">
                                            <small><strong>Insight:</strong> Risk distribution indicates project complexity level</small>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Code Quality Assessment -->
                <CodeQualityCard Result="@analysisResult"
                                 ComplexityLowThreshold="@ComplexityLowThreshold"
                                 ComplexityMediumThreshold="@ComplexityMediumThreshold" />

                <!-- Strategic Business Impact -->
                @if (businessMetrics != null)
                {
                    <BusinessMetricsCardComponent Metrics="@businessMetrics" />
                }

                <!-- Executive Assessment Summary -->
                <ExecutiveSummaryCard Result="@analysisResult"
                                      ComplexityLowThreshold="@ComplexityLowThreshold"
                                      ComplexityMediumThreshold="@ComplexityMediumThreshold"
                                      ComplexityHighThreshold="@ComplexityHighThreshold" />

                <!-- Risk Assessment Summary -->
                <RiskAssessmentCard Result="@analysisResult"
                                    ComplexityLowThreshold="@ComplexityLowThreshold"
                                    ComplexityMediumThreshold="@ComplexityMediumThreshold" />

                <!-- Intelligent Assessment Summary -->
                <AIAssessmentCard AssessmentText="@(analysisResult.OverallAssessment ?? string.Empty)" />

                <!-- Strategic Recommendations -->
                <StrategicRecommendationsCard Recommendations="@analysisResult.KeyRecommendations" />

                <!-- Detailed File Analysis -->
                <DetailedFileAnalysisCard FileResults="@analysisResult.FileResults"
                                          ComplexityLowThreshold="@ComplexityLowThreshold"
                                          ComplexityMediumThreshold="@ComplexityMediumThreshold"
                                          ComplexityHighThreshold="@ComplexityHighThreshold" />

                <!-- Legacy Issues -->
                <LegacyIssuesCard FileResults="@analysisResult.FileResults" />

                <!-- Executive Reporting -->
                <ReportGenerationCard IsGeneratingReport="@isGeneratingReport"
                                      OnGenerateReport="@DownloadExecutiveReport" />
            </div>
        </div>
    }
</div>

<style>
    .upload-area {
        border: 2px dashed #dee2e6;
        border-radius: 8px;
        transition: all 0.3s ease;
        cursor: pointer;
        min-height: 120px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

        .upload-area:hover {
            border-color: #0d6efd;
            background-color: #f8f9fa;
        }

    /* Improve card spacing and alignment */
    .card {
        margin-bottom: 1rem;
    }

    /* Better text formatting for AI insights */
    .ai-insight-text {
        font-size: 0.95rem;
        line-height: 1.6;
        color: #495057;
    }

    /* Improve file list display */
    .file-list-item {
        transition: background-color 0.2s ease;
    }

        .file-list-item:hover {
            background-color: #f8f9fa !important;
        }

    /* Center align charts better */
    .chart-container {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 250px;
    }

    .insight-text {
        color: #2c3e50 !important; /* Darker text for better readability */
        font-weight: 500;
    }

    .card-body small {
        color: #495057 !important; /* Ensure all small text is readable */
    }

    .spin {
        animation: spin 2s linear infinite;
    }

    @@keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }
</style>

@code {
    private string selectedAnalysisType = "general";
    private bool isAnalyzing = false;
    private bool isGeneratingReport = false;
    private string statusMessage = "";
    private List<IBrowserFile> selectedFiles = new List<IBrowserFile>();
    private MultiFileAnalysisResult? analysisResult;
    private BusinessMetrics? businessMetrics;

    private int ComplexityLowThreshold;
    private int ComplexityMediumThreshold;
    private int ComplexityHighThreshold;
    private int TokenCharEstimate;
    private bool businessRulesLoaded = false;

    protected override void OnInitialized()
    {
        // Load thresholds from configuration
        ComplexityLowThreshold = int.TryParse(Configuration["BusinessCalculationRules:ComplexityLowThreshold"], out var low) ? low : 30;
        ComplexityMediumThreshold = int.TryParse(Configuration["BusinessCalculationRules:ComplexityMediumThreshold"], out var med) ? med : 50;
        ComplexityHighThreshold = int.TryParse(Configuration["BusinessCalculationRules:ComplexityHighThreshold"], out var high) ? high : 70;
        TokenCharEstimate = int.TryParse(Configuration["BusinessCalculationRules:TokenCharEstimate"], out var token) ? token : 4;
        businessRulesLoaded = true;
    }

    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        // NOTE: No file count limit - batching handles any number of files
        // Using a large number for GetMultipleFiles to allow folder selection, but no actual limit enforced
        var newFiles = e.GetMultipleFiles(10000); // Large number to allow folder selection
        var csFiles = newFiles.Where(f => f.Name.EndsWith(".cs", StringComparison.OrdinalIgnoreCase)).ToList();

        // Filter out generated/designer files that aren't useful for analysis
        var sourceFiles = csFiles.Where(f =>
            !f.Name.Contains(".Designer.") &&
            !f.Name.Contains(".g.cs") &&
            !f.Name.Contains(".g.i.cs") &&
            !f.Name.Contains("AssemblyInfo.cs") &&
            !f.Name.Contains("GlobalAssemblyInfo.cs") &&
            !f.Name.StartsWith("Temp", StringComparison.OrdinalIgnoreCase) &&
            !f.Name.Contains("obj\\Debug") &&
            !f.Name.Contains("obj\\Release")
        ).ToList();

        if (sourceFiles.Count != newFiles.Count())
        {
            statusMessage = $"Folder selection: Found {sourceFiles.Count} relevant source files from {newFiles.Count()} total files.";
        }
        else
        {
            statusMessage = $"Successfully loaded {sourceFiles.Count} source files from project folder.";
        }

        // Clear existing and add new files
        // NOTE: No file count limit - batching handles any number of files
        selectedFiles.Clear();
        selectedFiles.AddRange(sourceFiles);

        StateHasChanged();
    }

    private void HandleDragOver(DragEventArgs e)
    {
        // Handled by preventDefault
    }

    private void HandleFileDrop(DragEventArgs e)
    {
        statusMessage = "File upload: Please use the Browse Files button to select source files.";
    }

    private void RemoveFile(IBrowserFile file)
    {
        selectedFiles.Remove(file);
        statusMessage = $"Removed {file.Name}. {selectedFiles.Count} files remaining for analysis.";
        StateHasChanged();
    }

    private void ClearFiles()
    {
        selectedFiles.Clear();
        statusMessage = "All files cleared. Ready for new file selection.";
        StateHasChanged();
    }

    private void HandleAnalysisTypeChange(string analysisType)
    {
        selectedAnalysisType = analysisType;
        StateHasChanged();
    }

    private async Task TestSimpleCharts()
    {
        try
        {
            Console.WriteLine("Testing simple charts...");
            statusMessage = "Testing chart functionality...";
            StateHasChanged();

            await Task.Delay(500); // Allow UI to render

            // Test if Chart.js is loaded
            var chartLoaded = await JSRuntime.InvokeAsync<bool>("eval", "typeof Chart !== 'undefined'");
            Console.WriteLine($"Chart.js loaded: {chartLoaded}");

            if (!chartLoaded)
            {
                statusMessage = "Chart.js library not loaded";
                return;
            }

            // Test simple chart creation
            var testResult = await JSRuntime.InvokeAsync<bool>("testSimpleChart");
            Console.WriteLine($"Test chart result: {testResult}");

            if (testResult)
            {
                statusMessage = "Chart test successful! Chart.js is working.";
            }
            else
            {
                statusMessage = "Chart test failed. Check console for details.";
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Test error: {ex.Message}");
            statusMessage = $"Test error: {ex.Message}";
        }
    }

    private async Task DebugChartElements()
    {
        try
        {
            Console.WriteLine("Debugging chart elements...");

            // Check if canvas elements exist
            var canvasInfo = await JSRuntime.InvokeAsync<string>("eval", @"
            Array.from(document.querySelectorAll('canvas')).map(c =>
                c.id + ': ' + c.offsetWidth + 'x' + c.offsetHeight
            ).join(', ')
        ");

            Console.WriteLine($"Canvas elements: {canvasInfo}");
            statusMessage = $"Canvas elements: {canvasInfo}";

            // Check Chart.js version
            var chartVersion = await JSRuntime.InvokeAsync<string>("eval", @"
            typeof Chart !== 'undefined' ? Chart.version || 'Unknown version' : 'Not loaded'
        ");

            Console.WriteLine($"Chart.js version: {chartVersion}");

        }
        catch (Exception ex)
        {
            Console.WriteLine($"Debug error: {ex.Message}");
            statusMessage = $"Debug error: {ex.Message}";
        }
    }

    private async Task GenerateCharts()
    {
        if (analysisResult?.FileResults == null || !analysisResult.FileResults.Any())
        {
            Console.WriteLine("No file results available for chart generation");
            return;
        }

        try
        {
            Console.WriteLine("Creating executive charts...");
            statusMessage = "Generating executive dashboard...";
            StateHasChanged();

            // Wait for DOM
            await Task.Delay(1500);

            // FIXED: Ensure we have valid data
            var validFiles = analysisResult.FileResults
                .Where(f => f != null && !string.IsNullOrEmpty(f.FileName))
                .ToList();

            if (!validFiles.Any())
            {
                Console.WriteLine("No valid files for chart generation");
                return;
            }

            // FIXED: Create complexity chart with proper data
            var topFiles = validFiles
                .OrderByDescending(f => f.ComplexityScore)
                .Take(8)
                .ToList();

            var fileNames = topFiles.Select(f => f.FileName.Length > 12 ? f.FileName.Substring(0, 12) + "..." : f.FileName).ToArray();
            var complexityScores = topFiles.Select(f => (object)f.ComplexityScore).ToArray();

            Console.WriteLine($"Creating complexity chart with {fileNames.Length} files: [{string.Join(", ", complexityScores)}]");

            var complexitySuccess = await JSRuntime.InvokeAsync<bool>("createSimpleChart",
                "complexityChart",
                "bar",
                fileNames,
                complexityScores,
                "Highest Risk Files - Complexity Analysis"
            );

            // FIXED: Create risk distribution with actual counts
            var lowCount = validFiles.Count(f => f.ComplexityScore < 40);
            var mediumCount = validFiles.Count(f => f.ComplexityScore >= 40 && f.ComplexityScore < 70);
            var highCount = validFiles.Count(f => f.ComplexityScore >= 70);

            Console.WriteLine($"Risk distribution: Low={lowCount}, Medium={mediumCount}, High={highCount}");

            if (lowCount + mediumCount + highCount > 0)
            {
                var riskLabels = new[] { "Low Risk", "Medium Risk", "High Risk" };
                var riskValues = new object[] { lowCount, mediumCount, highCount };

                var riskSuccess = await JSRuntime.InvokeAsync<bool>("createSimpleChart",
                    "riskChart",
                    "doughnut",
                    riskLabels,
                    riskValues,
                    "Project Risk Distribution"
                );

                Console.WriteLine($"Charts created: Complexity={complexitySuccess}, Risk={riskSuccess}");

                if (complexitySuccess || riskSuccess)
                {
                    statusMessage = "Executive dashboard created successfully.";
                }
                else
                {
                    statusMessage = "Dashboard generation completed. Review detailed analysis below.";
                }
            }
            else
            {
                statusMessage = "Analysis completed. Detailed insights available in file breakdown.";
            }

        }
        catch (Exception ex)
        {
            Console.WriteLine($"Chart error: {ex.Message}");
            statusMessage = "Analysis completed successfully. Detailed breakdown available below.";
        }
    }

    private async Task DownloadExecutiveReport()
    {
        if (analysisResult == null) return;

        isGeneratingReport = true;
        statusMessage = "Generating comprehensive executive report...";
        StateHasChanged();

        try
        {
            // Generate executive summary report
            var reportContent = GenerateExecutiveReport();
            var reportBytes = System.Text.Encoding.UTF8.GetBytes(reportContent);
            var fileName = $"executive-analysis-{selectedAnalysisType}-{DateTime.Now:yyyyMMdd-HHmmss}.md";

            await FileDownloadService.DownloadFileAsync(fileName, reportBytes, "text/markdown");
            statusMessage = $"Executive report generated successfully: {fileName}";
        }
        catch (Exception ex)
        {
            statusMessage = $"Report generation failed: {ex.Message}";
        }
        finally
        {
            isGeneratingReport = false;
            StateHasChanged();
        }
    }

    private string GenerateExecutiveReport()
    {
        if (analysisResult == null) return "";

        var report = new StringBuilder();

        // Executive Summary Header
        report.AppendLine("# Executive Project Analysis Report");
        report.AppendLine($"**Analysis Type**: {selectedAnalysisType.ToUpper()} ASSESSMENT");
        report.AppendLine($"**Report Generated**: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        report.AppendLine($"**Project Scope**: {analysisResult.TotalFiles} source files analyzed");
        report.AppendLine();

        // Executive Summary
        report.AppendLine("## Executive Summary");
        report.AppendLine($"This comprehensive analysis evaluated {analysisResult.TotalFiles} source files containing {analysisResult.TotalClasses} classes and {analysisResult.TotalMethods} methods. ");
        report.AppendLine($"The overall project complexity is rated as **{analysisResult.OverallRiskLevel}** with a risk score of {analysisResult.OverallComplexityScore}/100.");
        report.AppendLine();

        // FIXED: Use real data calculations directly in the report
        var manualHours = CalculateManualAnalysisHours(analysisResult);
        var costSavings = manualHours * 125;

        // Strategic Business Context with real data
        report.AppendLine("## Strategic Business Context");
        report.AppendLine("**Market Timing**: Legacy modernization market projected 15% annual growth");
        report.AppendLine("**Competitive Advantage**: AI-powered analysis delivers results 20x faster than manual assessment");
        report.AppendLine($"**Risk Management**: {analysisResult.OverallRiskLevel} complexity level (score: {analysisResult.OverallComplexityScore}/100) requires immediate attention");
        report.AppendLine();

        report.AppendLine("## Financial Impact Analysis");
        report.AppendLine($"**Code Complexity**: {analysisResult.TotalClasses} classes with {analysisResult.TotalMethods} methods analyzed");
        report.AppendLine($"**Estimated Manual Analysis Time**: {manualHours} hours");
        report.AppendLine($"**AI Analysis Time**: 3 minutes");
        report.AppendLine($"**Time Savings**: {manualHours} hours manual vs. 3 minutes AI = {manualHours * 60 - 3} minutes saved");
        report.AppendLine($"**Cost Avoidance**: ${costSavings:N0} in developer time cost avoidance");
        report.AppendLine();

        // Competitive Advantage Analysis with real data
        var speedMultiplier = (manualHours * 60) / 3;
        report.AppendLine("## Competitive Advantage Analysis");
        report.AppendLine();
        report.AppendLine("### Speed Advantage");
        report.AppendLine($"- **Traditional Approach**: {manualHours} hours manual analysis");
        report.AppendLine($"- **AI-Enhanced Approach**: 3 minutes automated analysis");
        report.AppendLine($"- **Speed Multiplier**: {speedMultiplier:F0}x faster time-to-insight");
        report.AppendLine();
        report.AppendLine("### Cost Advantage");
        report.AppendLine($"- **Traditional Manual Review**: ${costSavings:N0} ({manualHours} hours @ $125/hour)");
        report.AppendLine($"- **AI-Enhanced Analysis**: $5 per comprehensive assessment");
        report.AppendLine($"- **Cost Reduction**: ${costSavings - 5:N0} savings per analysis");
        report.AppendLine();
        report.AppendLine("### Project Metrics");
        report.AppendLine($"- **Code Complexity**: {analysisResult.OverallComplexityScore}/100 complexity score");
        report.AppendLine($"- **Risk Assessment**: {analysisResult.OverallRiskLevel} risk level based on actual code structure");
        report.AppendLine($"- **Analysis Scope**: {analysisResult.TotalClasses} classes, {analysisResult.TotalMethods} methods, {analysisResult.TotalProperties} properties");
        report.AppendLine();

        // Key Metrics
        report.AppendLine("## Key Performance Indicators");
        report.AppendLine("| Metric | Value | Assessment |");
        report.AppendLine("|--------|--------|------------|");
        report.AppendLine($"| Source Files | {analysisResult.TotalFiles} | {MultiFileHelpers.GetFileCountAssessment(analysisResult.TotalFiles)} |");
        report.AppendLine($"| Code Classes | {analysisResult.TotalClasses} | {MultiFileHelpers.GetClassCountAssessment(analysisResult.TotalClasses)} |");
        report.AppendLine($"| Methods | {analysisResult.TotalMethods} | {MultiFileHelpers.GetMethodCountAssessment(analysisResult.TotalMethods)} |");
        report.AppendLine($"| Complexity Score | {analysisResult.OverallComplexityScore}/100 | {analysisResult.OverallRiskLevel} Risk Level |");
        report.AppendLine();

        // Risk Assessment
        var riskStats = MultiFileHelpers.GetRiskStatistics(analysisResult);
        report.AppendLine("## Risk Assessment");
        report.AppendLine($"- **Low Risk Files**: {riskStats.low} files ({riskStats.lowPercent:F1}%)");
        report.AppendLine($"- **Medium Risk Files**: {riskStats.medium} files ({riskStats.mediumPercent:F1}%)");
        report.AppendLine($"- **High Risk Files**: {riskStats.high} files ({riskStats.highPercent:F1}%)");
        report.AppendLine();

        // Strategic Recommendations
        if (analysisResult.KeyRecommendations.Any())
        {
            report.AppendLine("## Strategic Recommendations");
            foreach (var recommendation in analysisResult.KeyRecommendations)
            {
                report.AppendLine($"- {recommendation}");
            }
            report.AppendLine();
        }

        // Business Impact
        report.AppendLine("## Business Impact Assessment");
        report.AppendLine($"**Migration Timeline**: {MultiFileHelpers.GetMigrationTimeline(analysisResult.OverallComplexityScore, ComplexityLowThreshold, ComplexityMediumThreshold, ComplexityHighThreshold)}");
        report.AppendLine($"**Resource Requirements**: {MultiFileHelpers.GetResourceRequirements(analysisResult.OverallComplexityScore, ComplexityLowThreshold, ComplexityMediumThreshold, ComplexityHighThreshold)}");
        report.AppendLine($"**Financial Impact**: {MultiFileHelpers.GetFinancialImpact(analysisResult.OverallComplexityScore, ComplexityLowThreshold, ComplexityMediumThreshold, ComplexityHighThreshold)}");
        report.AppendLine();

        // Technical Details
        report.AppendLine("## Detailed File Analysis");
        foreach (var file in analysisResult.FileResults.OrderByDescending(f => f.ComplexityScore).Take(10))
        {
            report.AppendLine($"### {file.FileName}");
            report.AppendLine($"- **Complexity Score**: {file.ComplexityScore}/100");
            report.AppendLine($"- **Classes**: {file.StaticAnalysis.ClassCount}");
            report.AppendLine($"- **Methods**: {file.StaticAnalysis.MethodCount}");
            report.AppendLine($"- **Properties**: {file.StaticAnalysis.PropertyCount}");
            if (!string.IsNullOrEmpty(file.AIInsight))
            {
                report.AppendLine($"- **Assessment**: {file.AIInsight}");
            }
            report.AppendLine();
        }

        // Next Steps
        report.AppendLine("## Recommended Next Steps");
        report.AppendLine("1. **Immediate Actions**: Address high-complexity files identified in this analysis");
        report.AppendLine("2. **Resource Planning**: Allocate development resources based on complexity assessment");
        report.AppendLine("3. **Timeline Development**: Create detailed project timeline using risk assessment data");
        report.AppendLine("4. **Stakeholder Communication**: Present findings to technical and business stakeholders");
        report.AppendLine("5. **Monitoring Strategy**: Establish metrics tracking for modernization progress");

        return report.ToString();
    }

    // NOTE: GetRiskStatistics, FormatFileSize, GetRiskTextColorClass, GetRiskDescription
    // have been moved to MultiFileHelpers.cs

    private async Task HandleIndividualFileSelection(InputFileChangeEventArgs e)
    {
        var newFiles = e.GetMultipleFiles(20); // Allow more files for folder selection
        var csFiles = newFiles.Where(f => f.Name.EndsWith(".cs", StringComparison.OrdinalIgnoreCase)).ToList();

        // Filter out common non-source files
        csFiles = csFiles.Where(f =>
            !f.Name.Contains(".Designer.") &&
            !f.Name.Contains(".g.cs") &&
            !f.Name.Contains("AssemblyInfo.cs") &&
            !f.Name.StartsWith("Temp", StringComparison.OrdinalIgnoreCase)
        ).ToList();

        if (csFiles.Count != newFiles.Count())
        {
            statusMessage = $"Filtered to {csFiles.Count} source files from {newFiles.Count()} total files.";
        }
        else
        {
            statusMessage = $"Successfully selected {csFiles.Count} source files.";
        }

        selectedFiles.AddRange(csFiles);
        StateHasChanged();
    }

    // NOTE: UI helper methods (GetComplexityBadgeClass, GetStatusText, etc.) have been
    // moved to MultiFileHelpers.cs and are used by extracted components directly.
    // Only page-specific methods remain here.

    private AnalysisProgress? analysisProgress;

    private async Task AnalyzeProject()
    {
        if (!selectedFiles.Any()) return;

        isAnalyzing = true;
        analysisProgress = new AnalysisProgress
        {
            TotalFiles = selectedFiles.Count,
            CurrentAnalysisType = selectedAnalysisType,
            StartTime = DateTime.Now
        };

        businessMetrics = null; // Reset business metrics
        statusMessage = $"Starting comprehensive analysis of {selectedFiles.Count} files...";
        StateHasChanged();

        var progress = new Progress<AnalysisProgress>(p =>
        {
            analysisProgress = p;
            InvokeAsync(StateHasChanged);
        });

        try
        {
            analysisResult = await MultiFileAnalysisService.AnalyzeMultipleFilesWithProgressAsync(
                selectedFiles, selectedAnalysisType, progress);

            // Calculate business metrics after analysis
            businessMetrics = MultiFileAnalysisService.CalculateBusinessMetrics(analysisResult);

            statusMessage = $"Analysis completed! ROI: {businessMetrics.EstimatedDeveloperHoursSaved * businessMetrics.AverageHourlyRate:C0} value delivered.";
            statusMessage += $" Compliance Cost Avoidance: {businessMetrics.ComplianceCostAvoidance:C0}.";
            statusMessage += $" Project Size: {businessMetrics.ProjectSize}.";
            // Adding more detail to the status message
            statusMessage += $" Estimated Developer Hours Saved: {businessMetrics.EstimatedDeveloperHoursSaved}.";
            statusMessage += $" Average Hourly Rate: {businessMetrics.AverageHourlyRate:C0}.";
            statusMessage += $" Compliance Cost Avoidance: {businessMetrics.ComplianceCostAvoidance:C0}.";
            statusMessage += $" Project Size: {businessMetrics.ProjectSize}.";

            await GenerateCharts();
        }
        catch (Exception ex)
        {
            statusMessage = $"Analysis encountered an error: {ex.Message}";
        }
        finally
        {
            isAnalyzing = false;
            analysisProgress = null;
            StateHasChanged();
        }
    }

    private async Task<BusinessMetrics> CalculateBusinessMetricsAsync(MultiFileAnalysisResult result)
    {
        return await Task.FromResult(new BusinessMetrics
        {
            EstimatedDeveloperHoursSaved = result.TotalMethods * 0.5m * ((result.OverallComplexityScore / 100m) + 0.5m),
            MigrationTimeline = result.OverallComplexityScore switch
            {
                < 30 => "2-4 weeks",
                < 50 => "4-8 weeks",
                < 70 => "8-12 weeks",
                _ => "12+ weeks"
            },
            RiskMitigation = $"{result.OverallRiskLevel} risk level with appropriate mitigation strategy",
            ComplianceCostAvoidance = result.OverallRiskLevel switch
            {
                "HIGH" => 15000m,
                "MEDIUM" => 8000m,
                "LOW" => 3000m,
                _ => 1000m
            },
            ProjectSize = result.TotalFiles switch
            {
                < 5 => "Small Project",
                < 15 => "Medium Project",
                < 30 => "Large Project",
                _ => "Enterprise Project"
            },
            RecommendedApproach = result.OverallComplexityScore switch
            {
                < 30 => "Standard development practices",
                < 50 => "Structured approach with experienced team",
                < 70 => "Phased migration with risk mitigation",
                _ => "Enterprise methodology with dedicated team"
            }
        });
    }

    private int CalculateManualAnalysisHours(MultiFileAnalysisResult result)
    {
        var baseHours = result.TotalClasses * 2; // 2 hours per class
        var methodHours = result.TotalMethods * 0.25; // 15 minutes per method
        var dependencyHours = result.TotalUsingStatements * 0.5; // 30 minutes per dependency

        return (int)(baseHours + methodHours + dependencyHours);
    }

    // NOTE: GetFileCountAssessment, GetClassCountAssessment, GetMethodCountAssessment,
    // GetMigrationTimeline, GetResourceRequirements, GetFinancialImpact have been
    // moved to MultiFileHelpers.cs - report generation now uses those helpers directly

    private int EstimateTokens(int charCount)
    {
        return charCount / TokenCharEstimate;
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("destroyAllCharts");
        }
        catch
        {
            // Ignore disposal errors
        }
    }
}